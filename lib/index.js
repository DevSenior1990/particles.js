(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("deep-extend"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "deep-extend"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("react"), require("deep-extend")) : factory(root["react"], root["deep-extend"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_4__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("/// <reference path=\"../typings/index.d.ts\" />\n\"use strict\";\n\nconst Particles_1 = __webpack_require__(1);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Particles_1.default;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.ts\n// module id = 0\n// module chunks = 0\n//# sourceURL=webpack:///./src/index.ts?");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("/// <reference path=\"../typings/index.d.ts\" />\n\"use strict\";\n\nconst React = __webpack_require__(2);\nconst react_1 = __webpack_require__(2);\nconst ParticlesLibrary_1 = __webpack_require__(3);\nclass Particles extends react_1.Component {\n    componentDidMount() {\n        let p = new ParticlesLibrary_1.default(this.canvas, {\n            particles: {\n                number: {\n                    value: 20\n                }\n            }\n        });\n    }\n    render() {\n        return React.createElement(\"div\", { id: 'particles-js' }, React.createElement(\"canvas\", { ref: c => this.canvas = c, style: {\n                width: \"100%\",\n                height: \"100%\"\n            } }));\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Particles;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Particles.tsx\n// module id = 1\n// module chunks = 0\n//# sourceURL=webpack:///./src/Particles.tsx?");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n//////////////////\n// WEBPACK FOOTER\n// external \"react\"\n// module id = 2\n// module chunks = 0\n//# sourceURL=webpack:///external_%22react%22?");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("/// <reference path=\"../../typings/index.d.ts\" />\n\"use strict\";\n\nconst deepExtend = __webpack_require__(4);\nconst _1 = __webpack_require__(5);\nclass ParticlesLibrary {\n    constructor(canvasElement, params) {\n        deepExtend(_1.defaultParams, params);\n        this.params = _1.defaultParams;\n        this.extendParams(canvasElement);\n        this.interact = new _1.Interact(this.params);\n        this.modes = new _1.Modes(this.params);\n        this.vendors = new _1.Vendors(this.params);\n        this.particleManager = new _1.ParticleManager(this.params, this.interact, this.modes, this.vendors, this);\n        console.log(this.params);\n    }\n    extendParams(canvasElement) {\n        this.extendCanvasDefinition(canvasElement);\n        this.extendTmpDefinition();\n        this.retinaInit = this.retinaInit.bind(this);\n        this.canvasInit = this.canvasInit.bind(this);\n        this.canvasSize = this.canvasSize.bind(this);\n        this.canvasPaint = this.canvasPaint.bind(this);\n        this.canvasClear = this.canvasClear.bind(this);\n        this.extendRetinaFunctionDefinition();\n        this.extendCanvasFunctionDefinition();\n        this.extendParticleFunctionDefinition();\n    }\n    extendCanvasDefinition(canvasElement) {\n        this.params.canvas = {\n            element: canvasElement,\n            width: canvasElement.offsetWidth,\n            height: canvasElement.offsetHeight\n        };\n    }\n    extendTmpDefinition() {\n        this.params.tmp.obj = {\n            size_value: this.params.particles.size.value,\n            size_anim_speed: this.params.particles.size.anim.speed,\n            move_speed: this.params.particles.move.speed,\n            line_linked_distance: this.params.particles.line_linked.distance,\n            line_linked_width: this.params.particles.line_linked.width,\n            mode_grab_distance: this.params.interactivity.modes.grab.distance,\n            mode_bubble_distance: this.params.interactivity.modes.bubble.distance,\n            mode_bubble_size: this.params.interactivity.modes.bubble.size,\n            mode_repulse_distance: this.params.interactivity.modes.repulse.distance\n        };\n    }\n    extendRetinaFunctionDefinition() {\n        this.params.fn.retinaInit = this.retinaInit;\n    }\n    retinaInit() {\n        if (this.params.retina_detect && window.devicePixelRatio > 1) {\n            this.params.canvas.pxratio = window.devicePixelRatio;\n            this.params.tmp.retina = true;\n            this.params.canvas.width = this.params.canvas.element.offsetWidth * this.params.canvas.pxratio;\n            this.params.canvas.height = this.params.canvas.element.offsetHeight * this.params.canvas.pxratio;\n            this.params.particles.size.value = this.params.tmp.obj.size_value * this.params.canvas.pxratio;\n            this.params.particles.size.anim.speed = this.params.tmp.obj.size_anim_speed * this.params.canvas.pxratio;\n            this.params.particles.move.speed = this.params.tmp.obj.move_speed * this.params.canvas.pxratio;\n            this.params.particles.line_linked.distance = this.params.tmp.obj.line_linked_distance * this.params.canvas.pxratio;\n            this.params.interactivity.modes.grab.distance = this.params.tmp.obj.mode_grab_distance * this.params.canvas.pxratio;\n            this.params.interactivity.modes.bubble.distance = this.params.tmp.obj.mode_bubble_distance * this.params.canvas.pxratio;\n            this.params.particles.line_linked.width = this.params.tmp.obj.line_linked_width * this.params.canvas.pxratio;\n            this.params.interactivity.modes.bubble.size = this.params.tmp.obj.mode_bubble_size * this.params.canvas.pxratio;\n            this.params.interactivity.modes.repulse.distance = this.params.tmp.obj.mode_repulse_distance * this.params.canvas.pxratio;\n        } else {\n            this.params.canvas.pxratio = 1;\n            this.params.tmp.retina = false;\n        }\n    }\n    extendCanvasFunctionDefinition() {\n        this.params.fn.canvasInit = this.canvasInit;\n        this.params.fn.canvasSize = this.canvasSize;\n        this.params.fn.canvasPaint = this.canvasPaint;\n        this.params.fn.canvasClear = this.canvasClear;\n    }\n    canvasInit() {\n        this.params.canvas.ctx = this.params.canvas.element.getContext('2d');\n    }\n    canvasSize() {\n        this.params.canvas.element.width = this.params.canvas.width;\n        this.params.canvas.element.height = this.params.canvas.height;\n        if (this.params && this.params.interactivity.events.resize) {\n            window.addEventListener('resize', this.onWindowResize);\n        }\n    }\n    canvasPaint() {\n        this.params.canvas.ctx.fillRect(0, 0, this.params.canvas.width, this.params.canvas.height);\n    }\n    canvasClear() {\n        this.params.canvas.ctx.clearRect(0, 0, this.params.canvas.width, this.params.canvas.height);\n    }\n    extendParticleFunctionDefinition() {\n        this.params.fn.particle = _1.Particle;\n    }\n    onWindowResize() {\n        this.params.canvas.width = this.params.canvas.element.offsetWidth;\n        this.params.canvas.height = this.params.canvas.element.offsetHeight;\n        if (this.params.tmp.retina) {\n            this.params.canvas.width *= this.params.canvas.pxratio;\n            this.params.canvas.height *= this.params.canvas.pxratio;\n        }\n        this.params.canvas.element.width = this.params.canvas.width;\n        this.params.canvas.element.height = this.params.canvas.height;\n        if (!this.params.particles.move.enable) {\n            this.params.fn.particlesEmpty();\n            this.params.fn.particlesCreate();\n            this.params.fn.particlesDraw();\n            this.params.fn.vendors.densityAutoParticles();\n        }\n        this.params.fn.vendors.densityAutoParticles();\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ParticlesLibrary;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ext/ParticlesLibrary.ts\n// module id = 3\n// module chunks = 0\n//# sourceURL=webpack:///./src/ext/ParticlesLibrary.ts?");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n//////////////////\n// WEBPACK FOOTER\n// external \"deep-extend\"\n// module id = 4\n// module chunks = 0\n//# sourceURL=webpack:///external_%22deep-extend%22?");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(__webpack_require__(6));\n__export(__webpack_require__(7));\nconst Interact_1 = __webpack_require__(8);\nexports.Interact = Interact_1.default;\nconst Modes_1 = __webpack_require__(9);\nexports.Modes = Modes_1.default;\nconst Particle_1 = __webpack_require__(10);\nexports.Particle = Particle_1.default;\nconst ParticleManager_1 = __webpack_require__(11);\nexports.ParticleManager = ParticleManager_1.default;\nconst ParticlesLibrary_1 = __webpack_require__(3);\nexports.ParticlesLibrary = ParticlesLibrary_1.default;\nconst Vendors_1 = __webpack_require__(12);\nexports.Vendors = Vendors_1.default;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ext/index.ts\n// module id = 5\n// module chunks = 0\n//# sourceURL=webpack:///./src/ext/index.ts?");

/***/ },
/* 6 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nlet defaultParams = {\n    canvas: {\n        element: null,\n        width: null,\n        height: null\n    },\n    particles: {\n        number: {\n            value: 400,\n            density: {\n                enable: true,\n                value_area: 800\n            }\n        },\n        color: {\n            value: '#fff'\n        },\n        shape: {\n            type: 'circle',\n            stroke: {\n                width: 0,\n                color: '#ff0000'\n            },\n            polygon: {\n                nb_sides: 5\n            },\n            image: {\n                src: '',\n                width: 100,\n                height: 100\n            }\n        },\n        opacity: {\n            value: 1,\n            random: false,\n            anim: {\n                enable: false,\n                speed: 2,\n                opacity_min: 0,\n                sync: false\n            }\n        },\n        size: {\n            value: 20,\n            random: false,\n            anim: {\n                enable: false,\n                speed: 20,\n                size_min: 0,\n                sync: false\n            }\n        },\n        line_linked: {\n            enable: true,\n            distance: 100,\n            color: '#fff',\n            opacity: 1,\n            width: 1\n        },\n        move: {\n            enable: true,\n            speed: 2,\n            direction: 'none',\n            random: false,\n            straight: false,\n            out_mode: 'out',\n            bounce: false,\n            attract: {\n                enable: false,\n                rotateX: 3000,\n                rotateY: 3000\n            }\n        },\n        array: []\n    },\n    interactivity: {\n        detect_on: 'canvas',\n        events: {\n            onhover: {\n                enable: true,\n                mode: 'grab'\n            },\n            onclick: {\n                enable: true,\n                mode: 'push'\n            },\n            resize: true\n        },\n        modes: {\n            grab: {\n                distance: 100,\n                line_linked: {\n                    opacity: 1\n                }\n            },\n            bubble: {\n                distance: 200,\n                size: 80,\n                duration: 0.4\n            },\n            repulse: {\n                distance: 200,\n                duration: 0.4\n            },\n            push: {\n                particles_nb: 4\n            },\n            remove: {\n                particles_nb: 2\n            }\n        },\n        mouse: {}\n    },\n    retina_detect: false,\n    fn: {\n        interact: {},\n        modes: {},\n        vendors: {}\n    },\n    tmp: {\n        obj: null,\n        retina: null\n    }\n};\nexports.defaultParams = defaultParams;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ext/defaultParams.ts\n// module id = 6\n// module chunks = 0\n//# sourceURL=webpack:///./src/ext/defaultParams.ts?");

/***/ },
/* 7 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nexports.hexToRgb = hex => {\n    let shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n    hex = hex.replace(shorthandRegex, (m, r, g, b) => {\n        return r + r + g + g + b + b;\n    });\n    let result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n    } : null;\n};\nexports.clamp = (number, min, max) => {\n    return Math.min(Math.max(number, min), max);\n};\nexports.isInArray = (value, array) => {\n    return array.indexOf(value) > -1;\n};\nlet requestAnimFrameProp = () => {\n    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || (callback => {\n        window.setTimeout(callback, 1000 / 60);\n    });\n};\nlet cancelRequestAnimFrameProp = () => {\n    return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || clearTimeout;\n};\nexports.requestAnimFrame = requestAnimFrameProp();\nexports.cancelRequestAnimFrame = cancelRequestAnimFrameProp();\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ext/Utils.ts\n// module id = 7\n// module chunks = 0\n//# sourceURL=webpack:///./src/ext/Utils.ts?");

/***/ },
/* 8 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nclass Interact {\n    constructor(params) {\n        this.params = params;\n        this.linkParticles = this.linkParticles.bind(this);\n        this.attractParticles = this.attractParticles.bind(this);\n        this.bounceParticles = this.bounceParticles.bind(this);\n        this.params.fn.interact.linkParticles = this.linkParticles;\n        this.params.fn.interact.attractParticles = this.attractParticles;\n        this.params.fn.interact.bounceParticles = this.bounceParticles;\n    }\n    linkParticles(p1, p2) {\n        let dx = p1.x - p2.x;\n        let dy = p1.y - p2.y;\n        let dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist <= this.params.particles.line_linked.distance) {\n            let opacity_line = this.params.particles.line_linked.opacity - dist / (1 / this.params.particles.line_linked.opacity) / this.params.particles.line_linked.distance;\n            if (opacity_line > 0) {\n                let color_line = this.params.particles.line_linked.color_rgb_line;\n                let { r, g, b } = color_line;\n                this.params.canvas.ctx.strokeStyle = `rgba( ${ r }, ${ g }, ${ b }, ${ opacity_line } )`;\n                this.params.canvas.ctx.lineWidth = this.params.particles.line_linked.width;\n                this.params.canvas.ctx.beginPath();\n                this.params.canvas.ctx.moveTo(p1.x, p2.y);\n                this.params.canvas.ctx.lineTo(p2.x, p2.y);\n                this.params.canvas.ctx.stroke();\n                this.params.canvas.ctx.closePath();\n            }\n        }\n    }\n    attractParticles(p1, p2) {\n        let dx = p1.x - p2.x;\n        let dy = p1.y - p2.y;\n        let dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist <= this.params.particles.line_linked.distance) {\n            let ax = dx / (this.params.particles.move.attract.rotateX * 1000);\n            let ay = dy / (this.params.particles.move.attract.rotateY * 1000);\n            p1.vx -= ax;\n            p1.vy -= ay;\n            p2.vx += ax;\n            p2.vy += ay;\n        }\n    }\n    bounceParticles(p1, p2) {\n        let dx = p1.x - p2.x;\n        let dy = p1.y - p2.y;\n        let dist = Math.sqrt(dx * dx + dy * dy);\n        let dist_p = p1.radius + p2.radius;\n        if (dist <= dist_p) {\n            p1.vx = -p1.vx;\n            p1.vy = -p1.vy;\n            p2.vx = -p2.vx;\n            p2.vy = -p2.vy;\n        }\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Interact;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ext/Interact.ts\n// module id = 8\n// module chunks = 0\n//# sourceURL=webpack:///./src/ext/Interact.ts?");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nconst _1 = __webpack_require__(5);\nclass Modes {\n    constructor(params) {\n        this.params = params;\n        this.pushParticles = this.pushParticles.bind(this);\n        this.removeParticles = this.removeParticles.bind(this);\n        this.bubbleParticle = this.bubbleParticle.bind(this);\n        this.repulseParticle = this.repulseParticle.bind(this);\n        this.grabParticle = this.grabParticle.bind(this);\n        this.params.fn.modes.pushParticles = this.pushParticles;\n        this.params.fn.modes.removeParticles = this.removeParticles;\n        this.params.fn.modes.bubbleParticle = this.bubbleParticle;\n        this.params.fn.modes.repulseParticle = this.repulseParticle;\n        this.params.fn.modes.grabParticle = this.grabParticle;\n    }\n    pushParticles(nb, pos) {\n        this.params.tmp.pushing = true;\n        if (!pos) pos = {\n            pos_x: Math.random() * this.params.canvas.width,\n            pos_y: Math.random() * this.params.canvas.height\n        };\n        for (let i = 0; i < nb; i++) {\n            this.params.particles.array.push(new _1.Particle(this.params, this.params.particles.color, this.params.particles.opacity.value, {\n                x: pos.pos_x,\n                y: pos.pos_y\n            }));\n            if (i == nb - 1) {\n                if (!this.params.particles.move.enable) {\n                    this.params.fn.particlesDraw();\n                }\n                this.params.tmp.pushing = false;\n            }\n        }\n    }\n    removeParticles(nb) {\n        this.params.particles.array.splice(0, nb);\n        if (!this.params.particles.move.enable) {\n            this.params.fn.particlesDraw();\n        }\n    }\n    bubbleParticle(particle) {\n        if (this.params.interactivity.events.onhover.enable && _1.isInArray('bubble', this.params.interactivity.events.onhover.mode)) {\n            let dx_mouse = particle.x - this.params.interactivity.mouse.pos_x;\n            let dy_mouse = particle.y - this.params.interactivity.mouse.pos_y;\n            let dist_mouse = Math.sqrt(dx_mouse * dx_mouse + dy_mouse * dy_mouse);\n            let ratio = 1 - dist_mouse / this.params.interactivity.modes.bubble.distance;\n            let init = () => {\n                particle.opacity_bubble = particle.opacity;\n                particle.radius_bubble = particle.radius;\n            };\n            if (dist_mouse <= this.params.interactivity.modes.bubble.distance) {\n                if (ratio >= 0 && this.params.interactivity.status == 'mousemove') {\n                    if (this.params.interactivity.modes.bubble.size != this.params.particles.size.value) {\n                        if (this.params.interactivity.modes.bubble.size > this.params.particles.size.value) {\n                            let size = particle.radius + this.params.interactivity.modes.bubble.size * ratio;\n                            if (size >= 0) {\n                                particle.radius_bubble = size;\n                            }\n                        } else {\n                            let dif = particle.radius - this.params.interactivity.modes.bubble.size;\n                            let size = particle.radius - dif * ratio;\n                            if (size > 0) {\n                                particle.radius_bubble = size;\n                            } else {\n                                particle.radius_bubble = 0;\n                            }\n                        }\n                    }\n                    if (this.params.interactivity.modes.bubble.opacity != this.params.particles.opacity.value) {\n                        if (this.params.interactivity.modes.bubble.opacity > this.params.particles.opacity.value) {\n                            let opacity = this.params.interactivity.modes.bubble.opacity * ratio;\n                            if (opacity > particle.opacity && opacity <= this.params.interactivity.modes.bubble.opacity) {\n                                particle.opacity_bubble = opacity;\n                            }\n                        } else {\n                            let opacity = particle.opacity - (this.params.particles.opacity.value - this.params.interactivity.modes.bubble.opacity) * ratio;\n                            if (opacity < particle.opacity && opacity >= this.params.interactivity.modes.bubble.opacity) {\n                                particle.opacity_bubble = opacity;\n                            }\n                        }\n                    }\n                }\n            } else {\n                init();\n            }\n            if (this.params.interactivity.status == 'mouseleave') {\n                init();\n            }\n        } else if (this.params.interactivity.events.onclick.enable && _1.isInArray('bubble', this.params.interactivity.events.onclick.mode)) {\n            if (this.params.tmp.bubble_clicking) {\n                let dx_mouse = particle.x - this.params.interactivity.mouse.click_pos_x;\n                let dy_mouse = particle.y - this.params.interactivity.mouse.click_pos_y;\n                let dist_mouse = Math.sqrt(dx_mouse * dx_mouse + dy_mouse * dy_mouse);\n                let time_spent = (new Date().getTime() - this.params.interactivity.mouse.click_time) / 1000;\n                if (time_spent > this.params.interactivity.modes.bubble.duration) {\n                    this.params.tmp.bubble_duration_end = true;\n                }\n                if (time_spent > this.params.interactivity.modes.bubble.duration * 2) {\n                    this.params.tmp.bubble_clicking = false;\n                    this.params.tmp.bubble_duration_end = false;\n                }\n                let process = (bubble_param, particles_param, p_obj_bubble, p_obj, id) => {\n                    // TODO Check where dist_mouse is initiated ( Line 890 )\n                    if (bubble_param != particles_param) {\n                        if (!this.params.tmp.bubble_duration_end) {\n                            if (dist_mouse <= this.params.interactivity.modes.bubble.distance) {\n                                let obj;\n                                if (p_obj_bubble != undefined) {\n                                    obj = p_obj_bubble;\n                                } else {\n                                    obj = p_obj;\n                                }\n                                if (obj != bubble_param) {\n                                    let value = p_obj - time_spent * (p_obj - bubble_param) / this.params.interactivity.modes.bubble.duration;\n                                    if (id == 'size') particle.radius_bubble = value;\n                                    if (id == 'opacity') particle.opacity_bubble = value;\n                                }\n                            } else {\n                                if (id == 'size') particle.radius_bubble = undefined;\n                                if (id == 'opacity') particle.opacity_bubble = undefined;\n                            }\n                        } else {\n                            if (p_obj_bubble != undefined) {\n                                let value_tmp = p_obj - time_spent * (p_obj - bubble_param) / this.params.interactivity.modes.bubble.duration;\n                                let dif = bubble_param - value_tmp;\n                                let value = bubble_param + dif;\n                                if (id == 'size') particle.radius_bubble = value;\n                                if (id == 'opacity') particle.opacity_bubble = value;\n                            }\n                        }\n                    }\n                };\n                if (this.params.tmp.bubble_clicking) {\n                    process(this.params.interactivity.modes.bubble.size, this.params.particles.size.value, particle.radius_bubble, particle.radius, 'size');\n                    process(this.params.interactivity.modes.bubble.opacity, this.params.particles.opacity.value, particle.opacity_bubble, particle.opacity, 'opacity');\n                }\n            }\n        }\n    }\n    repulseParticle(particle) {\n        if (this.params.interactivity.events.onhover.enable && _1.isInArray('repulse', this.params.interactivity.events.onhover.mode) && this.params.interactivity.status == 'mousemove') {\n            let dx_mouse = particle.x - this.params.interactivity.mouse.pos_x;\n            let dy_mouse = particle.y - this.params.interactivity.mouse.pos_y;\n            let dist_mouse = Math.sqrt(dx_mouse * dx_mouse + dy_mouse * dy_mouse);\n            let normVec = { x: dx_mouse / dist_mouse, y: dy_mouse / dist_mouse };\n            let repulseRadius = this.params.interactivity.modes.repulse.distance;\n            let velocity = 100;\n            let repulseFactor = _1.clamp(1 / repulseRadius * (-1 * Math.pow(dist_mouse / repulseRadius, 2) + 1) * repulseRadius * velocity, 0, 50);\n            let pos = {\n                x: particle.x + normVec.x * repulseFactor,\n                y: particle.y + normVec.y * repulseFactor\n            };\n            if (this.params.particles.move.out_mode == 'bounce') {\n                if (pos.x - particle.radius > 0 && pos.x + particle.radius < this.params.canvas.width) particle.x = pos.x;\n                if (pos.y - particle.radius > 0 && pos.y + particle.radius < this.params.canvas.height) particle.y = pos.y;\n            } else {\n                particle.x = pos.x;\n                particle.y = pos.y;\n            }\n        } else if (this.params.interactivity.events.onclick.enable && _1.isInArray('repulse', this.params.interactivity.events.onclick.mode)) {\n            if (!this.params.tmp.repulse_finish) {\n                this.params.tmp.repulse_count++;\n                if (this.params.tmp.repulse_count == this.params.particles.array.length) this.params.tmp.repulse_finish = true;\n            }\n            if (this.params.tmp.repulse_clicking) {\n                let repulseRadius = Math.pow(this.params.interactivity.modes.repulse.distance / 6, 3);\n                let dx = this.params.interactivity.mouse.click_pos_x - particle.x;\n                let dy = this.params.interactivity.mouse.click_pos_y - particle.y;\n                let d = dx * dx + dy * dy;\n                let force = -repulseRadius / d * 1;\n                let process = () => {\n                    let f = Math.atan2(dy, dx);\n                    particle.vx = force * Math.cos(f);\n                    particle.vy = force * Math.sin(f);\n                    if (this.params.particles.move.out_mode == 'bounce') {\n                        let pos = {\n                            x: particle.x + particle.vx,\n                            y: particle.y + particle.vy\n                        };\n                        if (pos.x + particle.radius > this.params.canvas.width) particle.vx = -particle.vx;else if (pos.x - particle.radius < 0) particle.vx = -particle.vx;\n                        if (pos.y + particle.radius > this.params.canvas.height) particle.vy = -particle.vy;else if (pos.y - particle.radius < 0) particle.vy = -particle.vy;\n                    }\n                };\n                if (d <= repulseRadius) {\n                    process();\n                }\n            } else {\n                if (this.params.tmp.repulse_clicking == false) {\n                    particle.vx = particle.vx_i;\n                    particle.vy = particle.vy_i;\n                }\n            }\n        }\n    }\n    grabParticle(particle) {\n        if (this.params.interactivity.events.onhover.enable && this.params.interactivity.status == 'onmousemove') {\n            let dx_mouse = particle.x - this.params.interactivity.mouse.pos_x;\n            let dy_mouse = particle.y - this.params.interactivity.mouse.pos_y;\n            let dist_mouse = Math.sqrt(dx_mouse * dx_mouse + dy_mouse * dy_mouse);\n            if (dist_mouse <= this.params.interactivity.modes.grab.distance) {\n                let opacity_line = this.params.interactivity.modes.grab.line_linked.opacity - dist_mouse / (1 / this.params.interactivity.modes.grab.line_linked.opacity) / this.params.interactivity.modes.grab.distance;\n                if (opacity_line > 0) {\n                    let color_line = this.params.particles.line_linked.color_rgb_line;\n                    let { r, g, b } = color_line;\n                    this.params.canvas.ctx.strokeStyle = `rgba( ${ r }, ${ g }, ${ b }, ${ opacity_line } )`;\n                    this.params.canvas.ctx.lineWidth = this.params.particles.line_linked.width;\n                    this.params.canvas.ctx.beginPath();\n                    this.params.canvas.ctx.moveTo(particle.x, particle.y);\n                    this.params.canvas.ctx.lineTo(this.params.interactivity.mouse.pos_x, this.params.interactivity.mouse.pos_y);\n                    this.params.canvas.ctx.stroke();\n                    this.params.canvas.ctx.closePath();\n                }\n            }\n        }\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Modes;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ext/Modes.ts\n// module id = 9\n// module chunks = 0\n//# sourceURL=webpack:///./src/ext/Modes.ts?");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nconst _1 = __webpack_require__(5);\nclass Particle {\n    constructor(params, color, opacity, position) {\n        this.params = params;\n        this.setupSize();\n        this.setupPosition(position);\n        this.setupColor(color);\n        this.setupOpacity();\n        this.setupAnimation();\n    }\n    setupSize() {\n        this.radius = (this.params.particles.size.random ? Math.random() : 1) * this.params.particles.size.value;\n        if (this.params.particles.size.anim.enable) {\n            this.size_status = false;\n            this.vs = this.params.particles.size.anim.speed / 100;\n            if (!this.params.particles.size.anim.sync) this.vs = this.vs * Math.random();\n        }\n    }\n    setupPosition(position) {\n        this.x = position ? position.x : Math.random() * this.params.canvas.width;\n        this.y = position ? position.y : Math.random() * this.params.canvas.height;\n        if (this.x > this.params.canvas.width - this.radius * 2) {\n            this.x = this.x - this.radius;\n        } else if (this.x < this.radius * 2) {\n            this.x = this.x + this.radius;\n        }\n        if (this.y > this.params.canvas.height - this.radius * 2) {\n            this.y = this.y - this.radius;\n        } else if (this.y < this.radius * 2) {\n            this.y = this.y + this.radius;\n        }\n        if (this.params.particles.move.bounce) {\n            this.params.fn.vendors.checkOverlap(this, position);\n        }\n    }\n    setupColor(color) {\n        this.color = {};\n        if (typeof color.value == 'object') {\n            if (color.value instanceof Array) {\n                let color_selected = color.value[Math.floor(Math.random() * this.params.particles.color.value.length)];\n                this.color.rgb = _1.hexToRgb(color_selected);\n            } else {\n                if (color.value.r != undefined && color.value.g != undefined && color.value.b != undefined) {\n                    let { r, g, b } = color.value;\n                    this.color.rgb = { r, g, b };\n                }\n                if (color.value.h != undefined && color.value.s != undefined && color.value.l != undefined) {\n                    let { h, s, l } = color.value;\n                    this.color.hsl = { h, s, l };\n                }\n            }\n        } else if (color.value == 'random') {\n            this.color.rgb = {\n                r: Math.floor(Math.random() * (255 - 0 + 1)) + 0,\n                g: Math.floor(Math.random() * (255 - 0 + 1)) + 0,\n                b: Math.floor(Math.random() * (255 - 0 + 1)) + 0\n            };\n        } else if (typeof color.value == 'string') {\n            this.color = color;\n            this.color.rgb = _1.hexToRgb(this.color.value);\n        }\n    }\n    setupOpacity() {\n        this.opacity = (this.params.particles.opacity.random ? Math.random() : 1) * this.params.particles.opacity.value;\n        if (this.params.particles.opacity.anim.enable) {\n            this.opacity_status = false;\n            this.vo = this.params.particles.opacity.anim.speed / 100;\n            if (!this.params.particles.opacity.anim.sync) {\n                this.vo = this.vo * Math.random();\n            }\n        }\n    }\n    setupAnimation() {\n        let velbase = null;\n        switch (this.params.particles.move.direction) {\n            case 'top':\n                velbase = { x: 0, y: -1 };\n                break;\n            case 'top-right':\n                velbase = { x: 0.5, y: -0.5 };\n                break;\n            case 'right':\n                velbase = { x: 1, y: 0 };\n                break;\n            case 'bottom-right':\n                velbase = { x: 0.5, y: 0.5 };\n                break;\n            case 'bottom':\n                velbase = { x: 0, y: 1 };\n                break;\n            case 'bottom-left':\n                velbase = { x: -0.5, y: 1 };\n                break;\n            case 'left':\n                velbase = { x: -1, y: 0 };\n                break;\n            case 'top-left':\n                velbase = { x: -0.5, y: -0.5 };\n                break;\n            default:\n                velbase = { x: 0, y: 0 };\n                break;\n        }\n        if (this.params.particles.move.straight) {\n            this.vx = velbase.x;\n            this.vy = velbase.y;\n            if (this.params.particles.move.random) {\n                this.vx = this.vx * Math.random();\n                this.vy = this.vy * Math.random();\n            }\n        } else {\n            this.vx = velbase.x + Math.random() - 0.5;\n            this.vy = velbase.y + Math.random() - 0.5;\n        }\n        this.vx_i = this.vx;\n        this.vy_i = this.vy;\n        let shape_type = this.params.particles.shape.type;\n        if (typeof shape_type == 'object') {\n            if (shape_type instanceof Array) {\n                let shape_selected = shape_type[Math.floor(Math.random() * shape_type.length)];\n                this.shape = shape_selected;\n            }\n        } else {\n            this.shape = shape_type;\n        }\n        if (this.shape == 'image') {\n            let sh = this.params.particles.shape;\n            this.img = {\n                src: sh.image.src,\n                ratio: sh.image.width / sh.image.height\n            };\n            if (!this.img.ratio) this.img.ratio = 1;\n            if (this.params.tmp.img_type == 'svg' && this.params.tmp.source_svg != undefined) {\n                this.params.fn.vendors.createSvgImg(this);\n                if (this.params.tmp.pushing) {\n                    this.img.loaded = false;\n                }\n            }\n        }\n    }\n    draw() {\n        let radius;\n        if (this.radius_bubble != undefined) {\n            radius = this.radius_bubble;\n        } else {\n            radius = this.radius;\n        }\n        let opacity;\n        if (this.opacity_bubble != undefined) {\n            opacity = this.opacity_bubble;\n        } else {\n            this.opacity;\n        }\n        let color_value;\n        if (this.color.rgb) {\n            let { r, g, b } = this.color.rgb;\n            color_value = `rgba( ${ r }, ${ g }, ${ b }, ${ opacity } )`;\n        } else {\n            let { h, s, l } = this.color.hsl;\n            color_value = `hsla( ${ h }, ${ s }, ${ l }, ${ opacity } )`;\n        }\n        this.params.canvas.ctx.fillStyle = color_value;\n        this.params.canvas.ctx.beginPath();\n        switch (this.shape) {\n            case 'circle':\n                this.params.canvas.ctx.arc(this.x, this.y, radius, 0, Math.PI * 2, false);\n                break;\n            case 'edge':\n                this.params.canvas.ctx.rect(this.x - radius, this.y - radius, radius * 2, radius * 2);\n                break;\n            case 'triangle':\n                this.params.fn.vendors.drawShape(this.params.canvas.ctx, this.x - radius, this.y + radius / 1.66, radius * 2, 3, 2);\n                break;\n            case 'polygon':\n                this.params.fn.vendors.drawShape(this.params.canvas.ctx, this.x - radius / (this.params.particles.shape.polygon.nb_sides / 3.5), this.y - radius / (2.66 / 3.5), radius * 2.66 / (this.params.particles.shape.polygon.nb_sides / 3), this.params.particles.shape.polygon.nb_sides, 1);\n                break;\n            case 'star':\n                this.params.fn.vendors.drawShape(this.params.canvas.ctx, this.x - radius * 2 / (this.params.particles.shape.polygon.nb_sides / 4), this.y - radius / (2 * 2.66 / 3.5), radius * 2 * 2.66 / (this.params.particles.shape.polygon.nb_sides / 3), this.params.particles.shape.polygon.nb_sides, 2);\n                break;\n            case 'image':\n                let draw = img_obj => {\n                    this.params.canvas.ctx.drawImage(img_obj, this.x - radius, this.y - radius, radius * 2, radius * 2 / this.img.ratio);\n                };\n                let img_obj;\n                if (this.params.tmp.img_type == 'svg') {\n                    img_obj = this.img.obj;\n                } else {\n                    img_obj = this.params.tmp.img_obj;\n                }\n                if (img_obj) draw(img_obj);\n                break;\n        }\n        this.params.canvas.ctx.closePath();\n        if (this.params.particles.shape.stroke.width > 0) {\n            this.params.canvas.ctx.strokeStyle = this.params.particles.shape.stroke.color;\n            this.params.canvas.ctx.lineWidth = this.params.particles.shape.stroke.width;\n            this.params.canvas.ctx.stroke();\n        }\n        this.params.canvas.ctx.fill();\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Particle;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ext/Particle.ts\n// module id = 10\n// module chunks = 0\n//# sourceURL=webpack:///./src/ext/Particle.ts?");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nconst _1 = __webpack_require__(5);\nclass ParticleManager {\n    constructor(params, interact, modes, vendors, lib) {\n        this.params = params;\n        this.interact = interact;\n        this.modes = modes;\n        this.vendors = vendors;\n        this.lib = lib;\n        this.particlesCreate = this.particlesCreate.bind(this);\n        this.particlesUpdate = this.particlesUpdate.bind(this);\n        this.particlesDraw = this.particlesDraw.bind(this);\n        this.particlesEmpty = this.particlesEmpty.bind(this);\n        this.particlesRefresh = this.particlesRefresh.bind(this);\n        this.extendParticleFunctionDefinition();\n    }\n    extendParticleFunctionDefinition() {\n        this.params.fn.particlesCreate = this.particlesCreate;\n        this.params.fn.particlesUpdate = this.particlesUpdate;\n        this.params.fn.particlesDraw = this.particlesDraw;\n        this.params.fn.particlesEmpty = this.particlesEmpty;\n        this.params.fn.particlesRefresh = this.particlesRefresh;\n    }\n    particlesCreate() {\n        let { color, opacity } = this.params.particles;\n        for (let i = 0; i < this.params.particles.number.value; i++) {\n            this.params.particles.array.push(new _1.Particle(this.params, color, opacity.value));\n        }\n    }\n    particlesUpdate() {\n        this.params.particles.array.forEach((particle, i) => {\n            if (this.params.particles.move.enable) {\n                let ms = this.params.particles.move.speed / 2;\n                particle.x = particle.vx * ms;\n                particle.y = particle.vy * ms;\n            }\n            if (this.params.particles.opacity.anim.enable) {\n                if (particle.opacity_status == true) {\n                    if (particle.opacity >= this.params.particles.opacity.value) particle.opacity_status = false;\n                    particle.opacity += particle.vo;\n                } else {\n                    if (particle.opacity <= this.params.particles.opacity.anim.opacity_min) particle.opacity_status = true;\n                    particle.opacity -= particle.vo;\n                }\n                if (particle.opacity < 0) particle.opacity = 0;\n            }\n            if (this.params.particles.size.anim.enable) {\n                if (particle.size_status == true) {\n                    if (particle.radius >= this.params.particles.size.value) particle.size_status = false;\n                    particle.radius += particle.vs;\n                } else {\n                    if (particle.radius <= this.params.particles.size.anim.size_min) particle.radius -= particle.vs;\n                }\n                if (particle.radius < 0) particle.radius = 0;\n            }\n            let new_pos;\n            if (this.params.particles.move.out_mode == 'bound') {\n                new_pos = {\n                    x_left: particle.radius,\n                    x_right: this.params.canvas.width,\n                    y_top: particle.radius,\n                    y_bottom: this.params.canvas.height\n                };\n            } else {\n                new_pos = {\n                    x_left: -particle.radius,\n                    x_right: this.params.canvas.width + particle.radius,\n                    y_top: -particle.radius,\n                    y_bottom: this.params.canvas.height + particle.radius\n                };\n            }\n            if (particle.x - particle.radius > this.params.canvas.width) {\n                particle.x = new_pos.x_left;\n                particle.y = Math.random() * this.params.canvas.height;\n            } else if (particle.x + particle.radius < 0) {\n                particle.x = new_pos.x_right;\n                particle.y = Math.random() * this.params.canvas.height;\n            }\n            if (particle.y - particle.radius > this.params.canvas.height) {\n                particle.y = new_pos.y_top;\n                particle.x = Math.random() * this.params.canvas.width;\n            } else if (particle.y + particle.radius < 0) {\n                particle.y = new_pos.y_bottom;\n                particle.x = Math.random() * this.params.canvas.width;\n            }\n            switch (this.params.particles.move.out_mode) {\n                case 'bounce':\n                    if (particle.x + particle.radius > this.params.canvas.width) particle.vx = -particle.vx;else if (particle.x - particle.radius < 0) particle.vx = -particle.vx;\n                    if (particle.y + particle.radius > this.params.canvas.height) particle.vy = -particle.vy;else if (particle.y - particle.radius < 0) particle.vy = -particle.vy;\n                    break;\n            }\n            if (_1.isInArray('grab', this.params.interactivity.events.onhover.mode)) {\n                this.params.fn.modes.grabParticle(particle);\n            }\n            if (_1.isInArray('bubble', this.params.interactivity.events.onhover.mode) || _1.isInArray('bubble', this.params.interactivity.events.onclick.mode)) {\n                this.params.fn.modes.bubbleParticle(particle);\n            }\n            if (_1.isInArray('repulse', this.params.interactivity.events.onhover.mode) || _1.isInArray('repulse', this.params.interactivity.events.onclick.mode)) {\n                this.params.fn.modes.repulseParticle(particle);\n            }\n            let { linkParticles, attractParticles, bounceParticles } = this.interact;\n            if (this.params.particles.line_linked.enable || this.params.particles.move.attract.enable) {\n                for (let j = i + 1; j < this.params.particles.array.length; j++) {\n                    let link = this.params.particles.array[j];\n                    if (this.params.particles.line_linked.enable) linkParticles(particle, link);\n                    if (this.params.particles.move.attract.enable) attractParticles(particle, link);\n                    if (this.params.particles.move.bounce) bounceParticles(particle, link);\n                }\n            }\n        });\n    }\n    particlesDraw() {\n        this.params.canvas.ctx.clearRect(0, 0, this.params.canvas.width, this.params.canvas.height);\n        this.params.fn.particlesUpdate();\n        this.params.particles.array.forEach(particle => {\n            particle.draw();\n        });\n    }\n    particlesEmpty() {\n        this.params.particles.array = [];\n    }\n    particlesRefresh() {\n        _1.cancelRequestAnimFrame(this.params.fn.checkAnimFrame);\n        _1.cancelRequestAnimFrame(this.params.fn.drawAnimFrame);\n        this.params.tmp.source_svg = undefined;\n        this.params.tmp.img_obj = undefined;\n        this.params.tmp.count_svg = 0;\n        this.particlesEmpty();\n        this.lib.canvasClear();\n        this.params.fn.vendors.start();\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ParticleManager;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ext/ParticleManager.ts\n// module id = 11\n// module chunks = 0\n//# sourceURL=webpack:///./src/ext/ParticleManager.ts?");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nconst _1 = __webpack_require__(5);\nclass Vendors {\n    constructor(params) {\n        this.params = params;\n        this.eventsListeners = this.eventsListeners.bind(this);\n        this.onMouseMove = this.onMouseMove.bind(this);\n        this.onMouseLeave = this.onMouseLeave.bind(this);\n        this.onClick = this.onClick.bind(this);\n        this.densityAutoParticles = this.densityAutoParticles.bind(this);\n        this.checkOverlap = this.checkOverlap.bind(this);\n        this.createSvgImg = this.createSvgImg.bind(this);\n        this.destroy = this.destroy.bind(this);\n        this.drawShape = this.drawShape.bind(this);\n        this.exportImg = this.exportImg.bind(this);\n        this.loadImg = this.loadImg.bind(this);\n        this.draw = this.draw.bind(this);\n        this.checkBeforeDraw = this.checkBeforeDraw.bind(this);\n        this.init = this.init.bind(this);\n        this.params.fn.vendors.eventsListeners = this.eventsListeners;\n        this.params.fn.vendors.densityAutoParticles = this.densityAutoParticles;\n        this.params.fn.vendors.checkOverlap = this.checkOverlap;\n        this.params.fn.vendors.createSvgImg = this.createSvgImg;\n        this.params.fn.vendors.destroy = this.destroy;\n        this.params.fn.vendors.drawShape = this.drawShape;\n        this.params.fn.vendors.exportImg = this.exportImg;\n        this.params.fn.vendors.loadImg = this.loadImg;\n        this.params.fn.vendors.draw = this.draw;\n        this.params.fn.vendors.checkBeforeDraw = this.checkBeforeDraw;\n        this.params.fn.vendors.init = this.init;\n    }\n    eventsListeners() {\n        let { canvas, interactivity } = this.params;\n        if (interactivity.detect_on == 'window') {\n            interactivity.el = window;\n        } else {\n            interactivity.el = canvas.element;\n        }\n        if (interactivity.events.onhover.enable || interactivity.events.onclick.enable) {\n            interactivity.el.addEventListener('mousemove', this.onMouseMove);\n            interactivity.el.addEventListener('mouseleave', this.onMouseLeave);\n        }\n        if (interactivity.events.onclick.enable) {\n            interactivity.el.addEventListener('click', this.onClick);\n        }\n    }\n    onMouseMove(event) {\n        let { canvas, interactivity, tmp } = this.params;\n        let pos;\n        if (interactivity.el == window) {\n            pos = {\n                x: event.clientX,\n                y: event.clientY\n            };\n        } else {\n            pos = {\n                x: event.offsetX || event.clientX,\n                y: event.offsetY || event.clientY\n            };\n        }\n        interactivity.mouse.pos_x = pos.x;\n        interactivity.mouse.pos_y = pos.y;\n        if (tmp.retina) {\n            interactivity.mouse.pos_x *= canvas.pxratio;\n            interactivity.mouse.pos_y *= canvas.pxratio;\n        }\n        interactivity.status = 'mousemove';\n    }\n    onMouseLeave(event) {\n        let { interactivity } = this.params;\n        interactivity.mouse.pos_x = null;\n        interactivity.mouse.pos_y = null;\n        interactivity.status = 'mouseleave';\n    }\n    onClick() {\n        let { fn, interactivity, particles, tmp } = this.params;\n        interactivity.mouse.click_pos_x = interactivity.mouse.pos_x;\n        interactivity.mouse.click_pos_y = interactivity.mouse.pos_y;\n        interactivity.mouse.click_time = new Date().getTime();\n        if (interactivity.events.onclick.enable) {\n            switch (interactivity.events.onclick.mode) {\n                case 'push':\n                    if (particles.move.enable) {\n                        fn.modes.pushParticles(interactivity.modes.push.particles_nb, interactivity.mouse);\n                    } else {\n                        if (interactivity.modes.push.particles_nb == 1) {\n                            fn.modes.pushParticles(interactivity.modes.push.particles_nb, interactivity.mouse);\n                        } else if (interactivity.modes.push.particles_nb > 1) {\n                            fn.modes.pushParticles(interactivity.modes.push.particles_nb);\n                        }\n                    }\n                    break;\n                case 'remove':\n                    fn.modes.removeParticles(interactivity.modes.remove.particles_nb);\n                    break;\n                case 'bubble':\n                    tmp.bubble_clicking = true;\n                    break;\n                case 'repulse':\n                    tmp.repulse_clicking = true;\n                    tmp.repulse_count = 0;\n                    tmp.repulse_finish = false;\n                    setTimeout(() => {\n                        tmp.repulse_clicking = false;\n                    }, interactivity.modes.repulse.duration * 1000);\n                    break;\n            }\n        }\n    }\n    densityAutoParticles() {\n        let { canvas, fn, particles, tmp } = this.params;\n        if (particles.number.density.enable) {\n            let area = canvas.element.width * canvas.element.height / 1000;\n            if (tmp.retina) {\n                area = area / canvas.pxratio * 2;\n            }\n            let nb_particles = area * particles.number.value / particles.number.density.value_area;\n            let missing_particles = particles.array.length - nb_particles;\n            if (missing_particles < 0) {\n                fn.modes.pushParticles(Math.abs(missing_particles));\n            } else {\n                fn.modes.removeParticles(missing_particles);\n            }\n        }\n    }\n    checkOverlap(p1, position) {\n        let { canvas, fn, particles } = this.params;\n        particles.array.forEach(particle => {\n            let p2 = particle;\n            let dx = p1.x - p2.x;\n            let dy = p1.y - p2.y;\n            let dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist <= p1.radius + p2.radius) {\n                p1.x = position ? position.x : Math.random() * canvas.width;\n                p1.y = position ? position.y : Math.random() * canvas.height;\n                fn.vendors.checkOverlap(p1);\n            }\n        });\n    }\n    createSvgImg(particle) {\n        let { tmp } = this.params;\n        let svgXml = tmp.source_svg;\n        let rgbHex = /#([0-9A-F]{3,6})/gi;\n        let coloredSvgXml = svgXml.replace(rgbHex, (m, r, g, b) => {\n            let color_value;\n            if (particle.color.rgb) {\n                let { r, g, b } = particle.color.rgb;\n                color_value = `rgba( ${ r }, ${ g }, ${ b }, ${ particle.opacity } )`;\n            } else {\n                let { h, s, l } = particle.color.hsl;\n                color_value = `rgba( ${ h }, ${ s }, ${ l }, ${ particle.opacity } )`;\n            }\n            return color_value;\n        });\n        let svg = new Blob([coloredSvgXml], {\n            type: 'image/svg+xml;charset=utf-8'\n        });\n        let DOMURL = window.URL || window;\n        let url = DOMURL.createObjectURL(svg);\n        let img = new Image();\n        img.addEventListener('load', () => {\n            particle.img.obj = img;\n            particle.img.loaded = true;\n            DOMURL.revokeObjectURL(url);\n            tmp.count_svg++;\n        });\n        img.src = url;\n    }\n    destroy() {\n        let { canvas, fn } = this.params;\n        cancelAnimationFrame(fn.drawAnimFrame);\n        canvas.element.remove();\n    }\n    drawShape(c, startX, startY, sideLength, sideCountNumerator, sideCountDenominator) {\n        let sideCount = sideCountNumerator * sideCountDenominator;\n        let decimalSides = sideCountNumerator / sideCountDenominator;\n        let interiorAngleDegrees = 180 * (decimalSides - 2) / decimalSides;\n        let interiorAngle = Math.PI - Math.PI * interiorAngleDegrees / 180;\n        c.save();\n        c.beginPath();\n        c.translate(startX, startY);\n        c.moveTo(0, 0);\n        for (let i = 0; i < sideCount; i++) {\n            c.lineTo(sideLength, 0);\n            c.translate(sideLength, 0);\n            c.rotate(interiorAngle);\n        }\n        c.fill();\n        c.restore();\n    }\n    exportImg() {\n        let { canvas } = this.params;\n        window.open(canvas.element.toDataURL('image/png'), '_blank');\n    }\n    loadImg(type) {\n        let { fn, particles, tmp } = this.params;\n        tmp.img_error = undefined;\n        if (particles.shape.image.src != '') {\n            if (type == 'svg') {\n                let xhr = new XMLHttpRequest();\n                xhr.open('GET', particles.shape.image.src);\n                xhr.onreadystatechange = data => {\n                    if (xhr.readyState == 4) {\n                        if (xhr.status == 200) {\n                            tmp.source_svg = data.currentTarget.response;\n                            fn.vendors.checkBeforeDraw();\n                        } else {\n                            console.log('Error react-particles-js - image not found');\n                            tmp.img_error = true;\n                        }\n                    }\n                };\n                xhr.send();\n            } else {\n                let img = new Image();\n                img.addEventListener('load', () => {\n                    tmp.img_obj = img;\n                    fn.vendors.checkBeforeDraw();\n                });\n                img.src = particles.shape.image.src;\n            }\n        } else {\n            console.log('Error react-particles-js - no image.src');\n            tmp.img_error = true;\n        }\n    }\n    draw() {\n        let { fn, particles, tmp } = this.params;\n        if (particles.shape.type == 'image') {\n            if (tmp.img_type == 'svg') {\n                if (tmp.count_svg >= particles.number.value) {\n                    fn.particlesDraw();\n                    if (!particles.move.enable) {\n                        _1.cancelRequestAnimFrame(fn.drawAnimFrame);\n                    } else {\n                        fn.drawAnimFrame = _1.requestAnimFrame(fn.vendors.draw);\n                    }\n                } else {\n                    if (!tmp.img_error) {\n                        fn.drawAnimFrame = _1.requestAnimFrame(fn.vendors.draw);\n                    }\n                }\n            } else {\n                if (tmp.img_obj != undefined) {\n                    fn.particlesDraw();\n                    if (!particles.move.enable) {\n                        _1.cancelRequestAnimFrame(fn.drawAnimFrame);\n                    } else {\n                        fn.drawAnimFrame = _1.requestAnimFrame(fn.vendors.draw);\n                    }\n                } else {\n                    if (!tmp.img_error) {\n                        fn.drawAnimFrame = _1.requestAnimFrame(fn.vendors.draw);\n                    }\n                }\n            }\n        } else {\n            fn.particlesDraw();\n            if (!particles.move.enable) {\n                _1.cancelRequestAnimFrame(fn.drawAnimFrame);\n            } else {\n                fn.drawAnimFrame = _1.requestAnimFrame(fn.vendors.draw);\n            }\n        }\n    }\n    checkBeforeDraw() {\n        let { fn, particles, tmp } = this.params;\n        if (particles.shape.type == 'image') {\n            if (tmp.img_type == 'svg' && tmp.source_svg == undefined) {\n                // Not clear what \"= requestAnimFrame( check )\" means\n                tmp.checkAnimFrame = _1.requestAnimFrame();\n            } else {\n                _1.cancelRequestAnimFrame(tmp.checkAnimFrame);\n                if (!tmp.img_error) {\n                    fn.vendors.init();\n                    fn.vendors.draw();\n                }\n            }\n        } else {\n            fn.vendors.init();\n            fn.vendors.draw();\n        }\n    }\n    init() {\n        let { fn, particles, tmp } = this.params;\n        if (_1.isInArray('image', particles.shape.type)) {\n            tmp.img_type = particles.shape.image.src.substr(particles.shape.image.src.length - 3);\n            fn.vendors.loadImg(tmp.img_type);\n        } else {\n            fn.vendors.checkBeforeDraw();\n        }\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Vendors;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ext/Vendors.ts\n// module id = 12\n// module chunks = 0\n//# sourceURL=webpack:///./src/ext/Vendors.ts?");

/***/ }
/******/ ])
});
;